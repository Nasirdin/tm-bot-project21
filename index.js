const { Telegraf, Markup } = require("telegraf");
const cron = require("node-cron");
const channelId = "-1001540449203";
require("dotenv").config();
const { readFile, writeFile, unLink } = require("fs").promises;

let userArray = [
  {
    userId: 2,
    chatId: 979996413,
    username: "danbazarbekov",
    bonus: 0,
    timeOutTraining: true,
    timeOutFood: true,
    timeOutClock: true,
  },
];
const commands = `
/start - –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞
/help - –ü–æ–º–æ—â—å
/mypoints - –ú–æ–∏ –±–∞–ª–ª—ã
/allreports - –î–∞–Ω–Ω—ã–µ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
/delete - –£–¥–∞–ª–∏—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–∞
/deleteofthelist - –£–¥–∞–ª–∏—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–∞ –∏–∑ —Å–ø–∏—Å–∫–∞
/add - –î–æ–±–∞–≤–∏—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–∞ –≤ —Å–ø–∏—Å–æ–∫

`;

const wordsForEveryDay = [
  "- –ù–µ –º–æ–≥—É –¥–æ–∂–¥–∞—Ç—å—Å—è, —á—Ç–æ–±—ã —Å–æ–±—Ä–∞—Ç—å —Ç—É—Å–æ–≤–∫—É –≤ —ç—Ç–∏ –≤—ã—Ö–æ–¥–Ω—ã–µ",
  "- –ê –µ—Å–ª–∏ –±—ã –º—ã —Å–µ–π—á–∞—Å –¥–µ—Ä–∂–∞–ª–∏—Å—å –∑–∞ —Ä—É–∫–∏ üòè",
  "- –ò–Ω–æ–≥–¥–∞ —Å–∞–º—ã–µ —Å–æ–≤–µ—Ä—à–µ–Ω–Ω—ã–µ –≤–µ—â–∏ –Ω–µ –∏–º–µ—é—Ç –Ω–∏–∫–∞–∫–æ–≥–æ —Å–º—ã—Å–ª–∞. –≠—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ ",
  "- –ü—Ä–æ—Å—Ç–∏, —è –ø–æ—Ç–µ—Ä—è–ª—Å—è, –≥–ª—è–¥—è –≤ —Ç–≤–æ–∏ –≥–ª–∞–∑–∞",
  "- ü¶àü¶à –≠—Ç–∏ —Ä–µ–±—è—Ç–∞ –∫–ª–∞—Å—Å–Ω—ã–µ",
  "- –ú–∞—Ö–∞—Ç—å—Å—è –±—É–¥–µ—à—å?",
  "- –° —Ç–æ–±–æ–π —Ç–∞–∫ —Ö–æ—Ä–æ—à–æ, –∞ –±–µ–∑ —Ç–µ–±—è –µ—â—ë –ª—É—á—à–µ üòä",
  "- –î–æ–±—Ä–æ –ø–æ–∂–∞–ª—É–π—Å—Ç–∞ –≤ –ø—Ä–æ–µ–∫—Ç —Å–∞–º—ã—Ö –∫—Ä—É—Ç—ã—Ö —Ä–µ–±—è—Ç",
  "- –ü—Ä–µ–∫—Ä–∞—Å–Ω—ã–π –º–∏—Ä, –≤–µ–¥—å –≤ –Ω—ë–º –µ—Å—Ç—å —Ç–∞–∫–∏–µ –∫—Ä–∞—Å–∏–≤—ã–µ –ª—é–¥–∏ –∫–∞–∫ —Ç—ã –∏ —Ç–≤–æ—è –¥–∞–ª—å–Ω–∞—è —Ç—ë—Ç—è",
  "- –¢—ã –Ω–µ –≤–æ–∑—Ä–∞–∂–∞–µ—à—å? –Ø –ø—ã—Ç–∞–ª—Å—è –Ω–µ –≤–ª—é–±–∏—Ç—Å—è —Å–µ–≥–æ–¥–Ω—è, –Ω–µ –≤—ã—à–ª–æ",
  "- –î–∞–≤–∞–π –ø–æ—Å–∏–¥–∏–º –≤—Å—é –Ω–æ—á—å –∏ –≤–º–µ—Å—Ç–µ –≤—Å—Ç—Ä–µ—Ç–∏–º –≤–æ—Å—Ö–æ–¥ —Å–æ–ª–Ω—Ü–∞. –ü–æ—Ç–æ–º –±—É–¥–µ–º —Å–ø–∞—Ç—å –¥–æ 6-–≤–µ—á–µ—Ä–∞ –∫–∞–∫ —É–±–∏—Ç—ã–µ",
  "- –î–∞–≤–∞–π —Å–æ—Å—Ç–∞—Ä–∏–º—Å—è –≤–º–µ—Å—Ç–µ",
  "- –Ø —Ö–æ—á—É –¥–∞—Ç—å —Ç–µ–±–µ –ª—É—á—à—É—é –≤–µ—Ä—Å–∏—é —Å–µ–±—è",
  "- –û, –Ω–∞—à–∞ –ª—é–±–æ–≤—å? —ç—Ç–æ –Ω–∞—à –º–∞–ª–µ–Ω—å–∫–∏–π —Å–µ–∫—Ä–µ—Ç",
  "- –ù–µ –≤—Å—ë –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å –ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫–∞! –ö—Ä–æ–º–µ —É—á—ë–±—ã",
  "- –í—ã –º–æ–∂–µ—Ç–µ –º–Ω–µ –ø–æ–º–æ—á—å? –£ –º–µ–Ω—è —Å–ª–æ–º–∞–ª—Å—è —Ç–µ–ª–µ—Ñ–æ–Ω –∏ –≤ –Ω–µ–º –Ω–µ—Ç –≤–∞—à–µ–≥–æ –Ω–æ–º–µ—Ä–∞",
  "- –£ –≤–∞—Å –æ—á–µ–Ω—å –º–Ω–æ–≥–æ –∫—Ä–∞—Å–∏–≤—ã—Ö –∏–∑–≥–∏–±–æ–≤, –Ω–æ —É–ª—ã–±–∫–∞ –ª—É—á—à–∏–π –∏–∑ –Ω–∏—Ö",
  "- –ó–¥–µ—Å—å –∂–∞—Ä–∫–æ –∏–ª–∏ –≤—ã –≥–æ—Ä—è—á–∏–π, —Å–ª–æ–≤–Ω–æ –æ–≥–æ–Ω—å?",
  "- –Å–ª–∫–∏ –ø–∞–ª–∫–∏, –ø—Ä–æ—Å–Ω–∏—Å—å —É–∂–µ",
  "- –ù—É –∏ –∫–∞–∫ —Å–ø–∞–ª–æ—Å—å —Å–µ–≥–æ–¥–Ω—è? üôÉ",
  "- –ß—ë, –ø—Ä–æ—Å–ø–∞–ª –∫–∞–∫ –∏ —è?",
];

const rFile = () => {
  return readFile(`${__dirname}/user.json`, { encoding: "utf8" }).then((text) => JSON.parse(text));
};

const wFile = (users) => {
  writeFile(`${__dirname}/user.json`, JSON.stringify(users), { encoding: "utf8" });
  return false;
};
const rNFile = () => {
  return readFile(`${__dirname}/newUsers.json`, { encoding: "utf8" }).then((text) => JSON.parse(text));
};

const wNFile = (users) => {
  writeFile(`${__dirname}/newUsers.json`, JSON.stringify(users), { encoding: "utf8" });
  return false;
};

const help = `–£ –≤–∞—Å –µ—Å—Ç—å –¥–æ—Å—Ç—É–ø —Ç–æ–ª—å–∫–æ –∫ —ç—Ç–∏–º –∫–æ–º–∞–Ω–¥–∞–º - 
/start - –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞
/help - –ü–æ–º–æ—â—å
/mypoints - –ú–æ–∏ –±–∞–ª–ª—ã
`;

const bot = new Telegraf(process.env.BOT_TOKEN);

const checkUser = async (ok, ctx) => {
  const users = await rNFile();
  const findUser = users.filter((user) => {
    return ctx.from.username === user.username;
  });
  if (!findUser[0]) {
    ctx.reply("–ß—Ç–æ–±—ã —Å—Ç–∞—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –ø—Ä–æ–µ–∫—Ç–∞ #PROJECT21 –æ–±—Ä–∞—â–∞–π—Ç–µ—Å—å –∫ @danbazarbekov");
    return false;
  } else {
    return true;
  }
};

bot.start(async (ctx) => {
  try {
    let ok = false;
    const findUser = await checkUser(ok, ctx);
    if (findUser) {
      ctx.reply(`–Ø —á–∞—Ç-–±–æ—Ç #PROJECT21: –∏ —è —Ç–≤–æ–π –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫ –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–µ 21-–¥–Ω–µ–π`);
      const users = await rFile();
      const username = ctx.message.from.username;
      const chatId = ctx.message.chat.id;
      const newUser = {
        chatId: chatId,
        username: username,
        bonus: 0,
        timeOutTraining: true,
        timeOutFood: true,
        timeOutClock: true,
      };
      if (!users[0]) {
        const newUsers = [{ userId: 1, ...newUser }];
        wFile(newUsers);
      } else {
        let findUser = false;
        users.filter((element) => {
          if (element.username === username) {
            findUser = true;
          }
        });
        if (!findUser) {
          const newArr = users.map((el) => {
            return el.userId;
          });
          userId = Math.max(...newArr) + 1;

          const newUsers = [...users, { userId, ...newUser }];
          wFile(newUsers);
        }
      }
    } else {
      return false;
    }
  } catch (e) {
    console.error(e);
  }
});
bot.command("allreports", async (ctx) => {
  try {
    if (ctx.from.username === "danbazarbekov" || ctx.from.username === "Nasirdin1") {
      const users = await rFile();
      const a = users.map((e) => {
        return `@${e.username} - ${e.bonus} –±–∞–ª–ª`;
      });
      ctx.reply(`–î–∞–Ω–Ω—ã–µ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
  
${a.join("                                                                                ")}`);
    } else {
      ctx.reply(`–ñ–∞–ª—å(, —á—Ç–æ –≤—ã –Ω–µ –î–∞—Å—Ç–∞–Ω )

${help}`);
    }
  } catch (error) {
    console.error(error);
  }
});

bot.command("add", async (ctx) => {
  try {
    if (ctx.from.username === "danbazarbekov" || ctx.from.username === "Nasirdin1") {
      const message = ctx.message.text.split(" ");
      if (message.length <= 1) {
        ctx.reply(`–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –Ω–∞–ø–∏—Å–∞–Ω–∏—è.
–ü—Ä–∏–º–µ—Ä: /add danbazarbekov`);
        return false;
      }
      const users = await rNFile();
      if (!users[0]) {
        const newUsers = [{ userId: "1" * 1, username: message[1] }];
        wNFile(newUsers);
        ctx.reply("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω!");
      } else {
        let findUser = false;
        users.filter((element) => {
          if (element.username === message[1]) {
            findUser = true;
          }
        });
        if (!findUser) {
          const newArr = users.map((el) => {
            return el.userId;
          });
          userId = Math.max(...newArr) + 1;

          const newUsers = [...users, { userId, username: message[1] }];
          wNFile(newUsers);
          ctx.reply("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω!");
        } else {
          ctx.reply("–ü–æ–ª–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω!");
        }
      }
    } else {
      ctx.reply(`–î–∞—Å—Ç–∞–Ω —ç—Ç–æ —Ç—ã? ü§®
  
${help}`);
    }
  } catch (error) {
    console.error(error);
  }
});

bot.command("delete", async (ctx) => {
  try {
    if (ctx.from.username === "danbazarbekov" || ctx.from.username === "Nasirdin1") {
      const message = ctx.message.text.split(" ");
      const users = await rFile();
      const deleteUser = users.filter((user) => {
        return `${user.username}` !== message[1];
      });
      if (message.length == 1) {
        ctx.reply(`–ê—É—É –≥–¥–µ –ø–æ–ª–æ–≤–∏–Ω–∞? )
–ü—Ä–∏–º–µ—Ä: /delete ${ctx.from.username}`);
        return false;
      }
      if (users.length === deleteUser.length) {
        ctx.reply(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω!
–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –Ω–∞–ø–∏—Å–∞–Ω–∏—è.
–ü—Ä–∏–º–µ—Ä: /delete ${ctx.from.username}`);
      } else {
        wFile(deleteUser);
        ctx.reply(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å @${message[1]} —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω`);
      }
    } else {
      ctx.reply(`–•–º–º! –ì–¥–µ –î–∞—Å—Ç–∞–Ω? üò†
      
${help}`);
    }
  } catch (error) {
    console.error(error);
  }
});

bot.command("deleteofthelist", async (ctx) => {
  try {
    if (ctx.from.username === "danbazarbekov" || ctx.from.username === "Nasirdin1") {
      const message = ctx.message.text.split(" ");
      const users = await rNFile();
      const deleteUser = users.filter((user) => {
        return `${user.username}` !== message[1];
      });
      if (message.length == 1) {
        ctx.reply(`–ê—É—É –≥–¥–µ –ø–æ–ª–æ–≤–∏–Ω–∞? )
–ü—Ä–∏–º–µ—Ä: /deleteofthelist ${ctx.from.username}`);
        return false;
      }
      if (users.length === deleteUser.length) {
        ctx.reply(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω!
–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –Ω–∞–ø–∏—Å–∞–Ω–∏—è.
–ü—Ä–∏–º–µ—Ä: /delete ${ctx.from.username}`);
      } else {
        wNFile(deleteUser);
        ctx.reply(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å @${message[1]} —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω`);
      }
    } else {
      ctx.reply(`–í—ã –∫—Ç–æ? –¥–∞ –¥–∞ –í—ã!

${help}`);
    }
  } catch (error) {
    console.error(error);
  }
});

bot.command("mypoints", async (ctx) => {
  console.log(userArray);

  try {
    let ok = false;

    const findUser = await checkUser(ok, ctx);
    if (findUser) {
      const users = await rFile();
      const point = await users.filter((user) => {
        return user.username === ctx.from.username;
      });
      ctx.replyWithHTML(`–í—ã –Ω–∞–±—Ä–∞–ª–∏ ${point[0].bonus} –±–∞–ª–ª–æ–≤`);
    } else {
      return false;
    }
  } catch (error) {
    console.error(error);
  }
});

bot.help((ctx) => ctx.reply(`–í–æ—Ç, —á–µ–º —è –º–æ–≥—É –ø–æ–º–æ—á—å:\n ${commands}`));

bot.on("video_note", async (ctx) => {
  try {
    let ok = false;
    const findUser = await checkUser(ok, ctx);
    if (findUser) {
      await ctx.replyWithHTML(
        "–≠—Ç–æ –æ—Ç—á—ë—Ç –∑–∞...",
        Markup.inlineKeyboard([
          [Markup.button.callback("- –¢—Ä–µ–Ω–∏—Ä–æ–≤–∫—É ", "training")],
          [Markup.button.callback("- –†–∞—Ü–∏–æ–Ω –ø–∏—Ç–∞–Ω–∏—è", "food")],
          [Markup.button.callback("- –ü–æ–¥—ä—ë–º –≤ 06:00", "clock")],
        ])
      );
      ctx.telegram.forwardMessage(channelId, ctx.message.chat.id, ctx.message.message_id);
    } else {
      return false;
    }
  } catch (error) {
    console.error(error);
  }
});
bot.on("video", async (ctx) => {
  try {
    let ok = false;
    const findUser = await checkUser(ok, ctx);
    if (findUser) {
      await ctx.replyWithHTML(
        "–≠—Ç–æ –æ—Ç—á—ë—Ç –∑–∞...",
        Markup.inlineKeyboard([
          [Markup.button.callback("- –¢—Ä–µ–Ω–∏—Ä–æ–≤–∫—É ", "training")],
          [Markup.button.callback("- –†–∞—Ü–∏–æ–Ω –ø–∏—Ç–∞–Ω–∏—è", "food")],
          [Markup.button.callback("- –ü–æ–¥—ä—ë–º –≤ 06:00", "clock")],
        ])
      );
      ctx.telegram.forwardMessage(channelId, ctx.message.chat.id, ctx.message.message_id);
    } else {
      return false;
    }
  } catch (error) {
    console.error(error);
  }
});

const timeOut = (ctx, users) => {
  const timeOut = users.map((element) => {
    if (element.username === ctx.from.username) {
      const newBonus = {
        userId: element.userId,
        chatId: element.chatId,
        username: element.username,
        bonus: element.bonus + 1,
        timeOutTraining: true,
        timeOutFood: true,
        timeOutClock: true,
      };
      return newBonus;
    } else {
      return element;
    }
  });
  wFile(timeOut);
};
const report = async (users, ctx, type) => {
  try {
    await ctx.deleteMessage(ctx.callbackQuery.message.message_id);
    await ctx.replyWithHTML("‚úÖ –û—Ç—á—ë—Ç –ø—Ä–∏–Ω—è—Ç! + –±–∞–ª–ª");
    const addBonus = users.map((element) => {
      if (element.username === ctx.from.username) {
        const newBonus = {
          userId: element.userId,
          chatId: element.chatId,
          username: element.username,
          bonus: element.bonus + 1,
          timeOutTraining: type == "training" ? false : element.timeOutTraining,
          timeOutFood: type == "food" ? false : element.timeOutFood,
          timeOutClock: type == "clock" ? false : element.timeOutClock,
        };
        return newBonus;
      } else {
        return element;
      }
    });
    wFile(addBonus);
    cron.schedule("0 5 * * *", async () => {
      timeOut(ctx, users, type);
    });
  } catch (error) {
    console.error(error);
  }
};

bot.action(`training`, async (ctx) => {
  const users = await rFile();
  const userArray = users.filter((e) => {
    return e.username === ctx.from.username;
  });

  if (!userArray[0].timeOutTraining) {
    await ctx.replyWithHTML("–í—ã —É–∂–µ –æ—Ç–ø—Ä–∞–≤–∏–ª–∏ –æ—Ç—á–µ—Ç –æ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–µ!");
  } else {
    let type = ctx.update.callback_query.data;
    report(users, ctx, type);
  }
});

bot.action(`food`, async (ctx) => {
  const users = await rFile();
  const userArray = users.filter((e) => {
    return e.username === ctx.from.username;
  });
  if (!userArray[0].timeOutFood) {
    await ctx.replyWithHTML("–í—ã —É–∂–µ –æ—Ç–ø—Ä–∞–≤–∏–ª–∏ –æ—Ç—á–µ—Ç!");
  } else {
    let type = ctx.update.callback_query.data;
    report(users, ctx, type);
  }
});

bot.action(`clock`, async (ctx) => {
  const users = await rFile();
  const userArray = users.filter((e) => {
    return e.username === ctx.from.username;
  });
  if (!userArray[0].timeOutClock) {
    await ctx.replyWithHTML("–í—ã —É–∂–µ –æ—Ç–ø—Ä–∞–≤–∏–ª–∏ –æ—Ç—á–µ—Ç");
  } else {
    let type = ctx.update.callback_query.data;
    report(users, ctx, type);
  }
});
let textOfTheDay = 15;

cron.schedule("*/2 * * * *", async () => {
  const users = await rFile();
  if (textOfTheDay == 21) {
    textOfTheDay = 0;
  } else {
    textOfTheDay += 1;
  }
  users.map((user) => {
    bot.telegram.sendMessage(
      user.chatId,
      !wordsForEveryDay[textOfTheDay] ? wordsForEveryDay[7] : wordsForEveryDay[textOfTheDay]
    );
  });
});

bot.launch();
process.once("SIGINT", () => bot.stop("SIGINT"));
process.once("SIGTERM", () => bot.stop("SIGTERM"));


// [
//   {
//     "userId": 1,
//     "chatId": 654924716,
//     "username": "Nasirdin1",
//     "bonus": 0,
//     "timeOutTraining": true,
//     "timeOutFood": true,
//     "timeOutClock": true
//   },
//   {
//     "userId": 2,
//     "chatId": 979996413,
//     "username": "danbazarbekov",
//     "bonus": 1,
//     "timeOutTraining": true,
//     "timeOutFood": true,
//     "timeOutClock": true
//   }
// ]